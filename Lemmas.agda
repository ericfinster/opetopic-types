{-# OPTIONS --without-K --rewriting #-}

open import HoTT
open import Monad
open import MonadOver
open import Pb
open import OpetopicType

module Lemmas where

  -- Just going to accumulate random lemmas that clog the typechecker
  -- here so that we can use them in what follows...

  rotate : âˆ€ {â„“} {A : Type â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚) (q : aâ‚‚ == aâ‚) (r : aâ‚€ == aâ‚‚)
    â†’ p âˆ™ ! q == r
    â†’ p == r âˆ™ q
  rotate idp idp r s = s âˆ™ ! (âˆ™-unit-r r)

  pth-algâ‚€ : âˆ€ {â„“} {A : Set â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚) (q : aâ‚‚ == aâ‚) 
    â†’ p == (p âˆ™ ! q) âˆ™ q 
  pth-algâ‚€ idp idp = idp

  pth-algâ‚ : âˆ€ {â„“} {A : Set â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚‚) (q : aâ‚ == aâ‚€) 
    â†’ p == (! q âˆ™ idp) âˆ™ q âˆ™ p
  pth-algâ‚ idp idp = idp 

  -- Lemma about transporting in constructors
  typ-trans-inv : (M : ğ•„) (Mâ†“ : ğ•„â†“ M)
    â†’ {i : Idx M} {c : Cns M i}
    â†’ {j j' : Idxâ†“ Mâ†“ i} (e : j == j')
    â†’ (d : Cnsâ†“ Mâ†“ j c) (p : Pos M c)
    â†’ Typâ†“ Mâ†“ (transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) e d) p == Typâ†“ Mâ†“ d p
  typ-trans-inv M Mâ†“ idp d p = idp

  fst=-comm : âˆ€ {i j} {A : Type i} {B : A â†’ Type j}
    â†’ {x y z : Î£ A B} (p : y == x) (q : y == z)
    â†’ fst= (! p âˆ™ q) == ! (fst= p) âˆ™ fst= q
  fst=-comm idp idp = idp

  --
  -- Various generic lemmas about indices and so on in the slice
  -- generated by a monad over ....
  --
  
  module SliceOver (M : ğ•„) (Mâ†“ : ğ•„â†“ M) where

    Plbk : ğ•„
    Plbk = Pb M (Idxâ†“ Mâ†“)

    Plbkâ†“ : ğ•„â†“ Plbk
    Plbkâ†“ = Pbâ†“ Mâ†“ (Idxâ†“ Mâ†“) (Î» i j k â†’ j == k)
    
    Slc : ğ•„
    Slc = Slice Plbk

    Slcâ†“ : ğ•„â†“ Slc
    Slcâ†“ = Sliceâ†“ Plbkâ†“
  
    -- An explicit description of equalities in Idxâ†“ Slcâ†“ 
    slc-idx-lem : (i : Idx M) (j : Idxâ†“ Mâ†“ i)
      â†’ (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
      â†’ {jâ‚€ : Idxâ†“ Mâ†“ i} {eâ‚€ : jâ‚€ == j}
      â†’ {dâ‚€ : Cnsâ†“ Mâ†“ jâ‚€ c} {Î±â‚€ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚€ p == Î½ p}
      â†’ {jâ‚ : Idxâ†“ Mâ†“ i} {eâ‚ : jâ‚ == j}
      â†’ {dâ‚ : Cnsâ†“ Mâ†“ jâ‚ c} {Î±â‚ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚ p == Î½ p}
      â†’ (q : jâ‚€ == jâ‚) (r : eâ‚€ == q âˆ™ eâ‚)
      â†’ (s : transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) q dâ‚€ == dâ‚)
      â†’ (t : (p : Pos M c) â†’ Î±â‚€ p == (! (typ-trans-inv M Mâ†“ q dâ‚€ p) âˆ™ ap (Î» x â†’ Typâ†“ Mâ†“ x p) s) âˆ™ Î±â‚ p)
      â†’ Path {A = Idxâ†“ Slcâ†“ ((i , j) , c , Î½)}
        ((jâ‚€ , eâ‚€) , (dâ‚€ , Î±â‚€)) ((jâ‚ , eâ‚) , (dâ‚ , Î±â‚)) 
    slc-idx-lem i j c Î½ idp idp idp t =
      pair= idp (pair= idp (Î»= t))

    slc-idx-lem-coh : (i : Idx M) (j : Idxâ†“ Mâ†“ i)
      â†’ (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
      â†’ {jâ‚€ : Idxâ†“ Mâ†“ i} {eâ‚€ : jâ‚€ == j}
      â†’ {dâ‚€ : Cnsâ†“ Mâ†“ jâ‚€ c} {Î±â‚€ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚€ p == Î½ p}
      â†’ {jâ‚ : Idxâ†“ Mâ†“ i} {eâ‚ : jâ‚ == j}
      â†’ {dâ‚ : Cnsâ†“ Mâ†“ jâ‚ c} {Î±â‚ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚ p == Î½ p}
      â†’ (q : jâ‚€ == jâ‚) (r : eâ‚€ == q âˆ™ eâ‚)
      â†’ (s : transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) q dâ‚€ == dâ‚)
      â†’ (t : (p : Pos M c) â†’ Î±â‚€ p == (! (typ-trans-inv M Mâ†“ q dâ‚€ p) âˆ™ ap (Î» x â†’ Typâ†“ Mâ†“ x p) s) âˆ™ Î±â‚ p)
      â†’ fst= (slc-idx-lem i j c Î½ q r s t) == pair= q (â†“-idf=cst-in r)
    slc-idx-lem-coh i j c Î½ idp idp idp t = fst=-Î² idp (pair= idp (Î»= t)) 

    postulate
      â†“-Pb-out : {i : Idx Plbk} {c : Cns Plbk i}
        â†’ {jâ‚€ jâ‚ : Idxâ†“ Plbkâ†“ i} {e : jâ‚€ == jâ‚}
        â†’ {dâ‚€ : Cnsâ†“ Plbkâ†“ jâ‚€ c} {dâ‚ : Cnsâ†“ Plbkâ†“ jâ‚ c}
        â†’ (r : dâ‚€ == dâ‚ [ (Î» x â†’ Cnsâ†“ (Pbâ†“ Mâ†“ (Idxâ†“ Mâ†“) (Î» i j k â†’ j == k)) x c) â†“ e ])
        â†’ (p : Pos Plbk {f = i} c) â†’ snd dâ‚€ p == (! (typ-trans-inv M Mâ†“ (fst= e) (fst dâ‚€) p) âˆ™
             ap (Î» x â†’ Typâ†“ Mâ†“ x p) (to-transp (â†“-ap-in (Î» z â†’ Cnsâ†“ Mâ†“ z (fst c)) fst (â†“-Î£-fst r)))) âˆ™ snd dâ‚ p
    -- â†“-Pb-out i c jâ‚€ jâ‚ e dâ‚€ dâ‚ = {!!}

