{-# OPTIONS --without-K --rewriting #-}

open import HoTT
open import Monad
open import MonadOver
open import Pb
open import OpetopicType

module Lemmas where

  -- Just going to accumulate random lemmas that clog the typechecker
  -- here so that we can use them in what follows...

  rotate : âˆ€ {â„“} {A : Type â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚) (q : aâ‚‚ == aâ‚) (r : aâ‚€ == aâ‚‚)
    â†’ p âˆ™ ! q == r
    â†’ p == r âˆ™ q
  rotate idp idp r s = s âˆ™ ! (âˆ™-unit-r r)

  pth-algâ‚€ : âˆ€ {â„“} {A : Set â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚) (q : aâ‚‚ == aâ‚) 
    â†’ p == (p âˆ™ ! q) âˆ™ q 
  pth-algâ‚€ idp idp = idp

  pth-algâ‚ : âˆ€ {â„“} {A : Set â„“} {aâ‚€ aâ‚ aâ‚‚ : A}
    â†’ (p : aâ‚€ == aâ‚‚) (q : aâ‚ == aâ‚€) 
    â†’ p == (! q âˆ™ idp) âˆ™ q âˆ™ p
  pth-algâ‚ idp idp = idp 

  -- Lemma about transporting in constructors
  typ-trans-inv : (M : ğ•„) (Mâ†“ : ğ•„â†“ M)
    â†’ {i : Idx M} {c : Cns M i}
    â†’ {j j' : Idxâ†“ Mâ†“ i} (e : j == j')
    â†’ (d : Cnsâ†“ Mâ†“ j c) (p : Pos M c)
    â†’ Typâ†“ Mâ†“ (transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) e d) p == Typâ†“ Mâ†“ d p
  typ-trans-inv M Mâ†“ idp d p = idp

  fst=-comm : âˆ€ {i j} {A : Type i} {B : A â†’ Type j}
    â†’ {x y z : Î£ A B} (p : y == x) (q : y == z)
    â†’ fst= (! p âˆ™ q) == ! (fst= p) âˆ™ fst= q
  fst=-comm idp idp = idp

  Î£-fst-triv-lemâ‚€ : âˆ€ {i j} {A : Type i} {B : A â†’ Type j}
    â†’ {a : A} {bâ‚€ bâ‚ : B a} (p : Path {A = Î£ A B} (a , bâ‚€) (a , bâ‚))
    â†’ (q : fst= p == idp)
    â†’ bâ‚€ == bâ‚
  Î£-fst-triv-lemâ‚€ {B = B} {bâ‚€ = bâ‚€} {bâ‚ = bâ‚} p q =
    transport (Î» x â†’ bâ‚€ == bâ‚ [ B â†“ x ]) q (snd= p) 
  
  Î£-fst-triv-lemâ‚ : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j}
    â†’ {C : Î£ A B â†’ Type k}
    â†’ {a : A} {bâ‚€ bâ‚ : B a} (p : (a , bâ‚€) == (a , bâ‚))
    â†’ (q : fst= p == idp)
    â†’ {x : C (a , bâ‚€)} {y : C (a , bâ‚)}
    â†’ x == y [ C â†“ p ]
    â†’ x == y [ (Î» b â†’ C (a , b)) â†“ Î£-fst-triv-lemâ‚€ p q ] 
  Î£-fst-triv-lemâ‚ {B = B} {C = C} {a = a} {bâ‚€ = bâ‚€} {bâ‚ = bâ‚} p q {x} {y} r =
    â†“-ap-out C (a ,_) (Î£-fst-triv-lemâ‚€ p q) (transport (Î» z â†’ x == y [ C â†“ z ]) pth r)

    where pth : p == pair= idp (Î£-fst-triv-lemâ‚€ p q)
          pth = pair=-Î· p âˆ™ (ap (Î» z â†’ pair= (fst z) (snd z))
            (pair= q (from-transp (Î» z â†’ bâ‚€ == bâ‚ [ B â†“ z ]) q {u = snd= p} idp)))

  --
  -- Various generic lemmas about indices and so on in the slice
  -- generated by a monad over ....
  --
  
  module SliceOver (M : ğ•„) (Mâ†“ : ğ•„â†“ M) where

    Plbk : ğ•„
    Plbk = Pb M (Idxâ†“ Mâ†“)

    Plbkâ†“ : ğ•„â†“ Plbk
    Plbkâ†“ = Pbâ†“ Mâ†“ (Idxâ†“ Mâ†“) (Î» i j k â†’ j == k)
    
    Slc : ğ•„
    Slc = Slice Plbk

    Slcâ†“ : ğ•„â†“ Slc
    Slcâ†“ = Sliceâ†“ Plbkâ†“
  
    -- An explicit description of equalities in Idxâ†“ Slcâ†“ 
    slc-idx-lem : (i : Idx M) (j : Idxâ†“ Mâ†“ i)
      â†’ (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
      â†’ {jâ‚€ : Idxâ†“ Mâ†“ i} {eâ‚€ : jâ‚€ == j}
      â†’ {dâ‚€ : Cnsâ†“ Mâ†“ jâ‚€ c} {Î±â‚€ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚€ p == Î½ p}
      â†’ {jâ‚ : Idxâ†“ Mâ†“ i} {eâ‚ : jâ‚ == j}
      â†’ {dâ‚ : Cnsâ†“ Mâ†“ jâ‚ c} {Î±â‚ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚ p == Î½ p}
      â†’ (q : jâ‚€ == jâ‚) (r : eâ‚€ == q âˆ™ eâ‚)
      â†’ (s : transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) q dâ‚€ == dâ‚)
      â†’ (t : (p : Pos M c) â†’ Î±â‚€ p == (! (typ-trans-inv M Mâ†“ q dâ‚€ p) âˆ™ ap (Î» x â†’ Typâ†“ Mâ†“ x p) s) âˆ™ Î±â‚ p)
      â†’ Path {A = Idxâ†“ Slcâ†“ ((i , j) , c , Î½)}
        ((jâ‚€ , eâ‚€) , (dâ‚€ , Î±â‚€)) ((jâ‚ , eâ‚) , (dâ‚ , Î±â‚)) 
    slc-idx-lem i j c Î½ idp idp idp t =
      pair= idp (pair= idp (Î»= t))

    slc-idx-lem-coh : (i : Idx M) (j : Idxâ†“ Mâ†“ i)
      â†’ (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
      â†’ {jâ‚€ : Idxâ†“ Mâ†“ i} {eâ‚€ : jâ‚€ == j}
      â†’ {dâ‚€ : Cnsâ†“ Mâ†“ jâ‚€ c} {Î±â‚€ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚€ p == Î½ p}
      â†’ {jâ‚ : Idxâ†“ Mâ†“ i} {eâ‚ : jâ‚ == j}
      â†’ {dâ‚ : Cnsâ†“ Mâ†“ jâ‚ c} {Î±â‚ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚ p == Î½ p}
      â†’ (q : jâ‚€ == jâ‚) (r : eâ‚€ == q âˆ™ eâ‚)
      â†’ (s : transport (Î» x â†’ Cnsâ†“ Mâ†“ x c) q dâ‚€ == dâ‚)
      â†’ (t : (p : Pos M c) â†’ Î±â‚€ p == (! (typ-trans-inv M Mâ†“ q dâ‚€ p) âˆ™ ap (Î» x â†’ Typâ†“ Mâ†“ x p) s) âˆ™ Î±â‚ p)
      â†’ fst= (slc-idx-lem i j c Î½ q r s t) == pair= q (â†“-idf=cst-in r)
    slc-idx-lem-coh i j c Î½ idp idp idp t = fst=-Î² idp (pair= idp (Î»= t)) 

    -- A version with path overs ... could this simplify some things?
    slc-idx-lemâ†“ : (i : Idx M) (j : Idxâ†“ Mâ†“ i)
      â†’ (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
      â†’ {jâ‚€ : Idxâ†“ Mâ†“ i} {eâ‚€ : jâ‚€ == j}
      â†’ {dâ‚€ : Cnsâ†“ Mâ†“ jâ‚€ c} {Î±â‚€ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚€ p == Î½ p}
      â†’ {jâ‚ : Idxâ†“ Mâ†“ i} {eâ‚ : jâ‚ == j}
      â†’ {dâ‚ : Cnsâ†“ Mâ†“ jâ‚ c} {Î±â‚ : (p : Pos M c) â†’ Typâ†“ Mâ†“ dâ‚ p == Î½ p}
      â†’ (q : jâ‚€ == jâ‚) (r : eâ‚€ == q âˆ™ eâ‚)
      â†’ (s : dâ‚€ == dâ‚ [ (Î» x â†’ Cnsâ†“ Mâ†“ x c) â†“ q ])
      â†’ (t : (p : Pos M c) â†’ Î±â‚€ p == ap (Î» x â†’ Typâ†“ Mâ†“ (snd x) p) (pair= q s) âˆ™ Î±â‚ p)
      â†’ Path {A = Idxâ†“ Slcâ†“ ((i , j) , c , Î½)}
        ((jâ‚€ , eâ‚€) , (dâ‚€ , Î±â‚€)) ((jâ‚ , eâ‚) , (dâ‚ , Î±â‚)) 
    slc-idx-lemâ†“ i j c Î½ {jâ‚€} {eâ‚€} {dâ‚€} {Î±â‚€ = Î±â‚€} {Î±â‚ = Î±â‚} idp idp idp t =
      ap (Î» x â†’ ((jâ‚€ , eâ‚€) , dâ‚€ , x)) (Î»= t)

    module Helpers (i : Idx M) (j : Idxâ†“ Mâ†“ i)
             (c : Cns M i) (Î½ : (p : Pos M c) â†’ Idxâ†“ Mâ†“ (Typ M c p))
             (Î´ : (p : Pos M c) â†’ Cns Plbk (Typ M c p , Î½ p))
             (Îµ : (p : Pos M c) â†’ Cns Slc ((Typ M c p , Î½ p) , Î´ p))
             (d : Cnsâ†“ Mâ†“ j c) (typ-d=Î½ : (p : Pos M c) â†’ Typâ†“ Mâ†“ d p == Î½ p) where

      Î¼f = Î¼-pos-fst M c (fst âˆ˜ Î´)
      Î¼s = Î¼-pos-snd M c (fst âˆ˜ Î´)

      Î´Î¼ : (pq : Pos M (Î¼ M c (fst âˆ˜ Î´)))
        â†’ Idxâ†“ Mâ†“ (Typ M (fst (Î´ (Î¼f pq))) (Î¼s pq))
      Î´Î¼ pq = snd (Î´ (Î¼f pq)) (Î¼s pq) 

      Î´â†“Î¼ : (Î´â†“ : (p : Pos M c) â†’ Cnsâ†“ Plbkâ†“ (Typâ†“ Mâ†“ d p , typ-d=Î½ p) (Î´ p))
        â†’ (pq : Pos M (Î¼ M c (fst âˆ˜ Î´)))
        â†’ Typâ†“ Mâ†“ (fst (Î´â†“ (Î¼f pq))) (Î¼s pq)
        == snd (Î´ (Î¼f pq)) (Î¼s pq)
      Î´â†“Î¼ Î´â†“ pq = snd (Î´â†“ (Î¼f pq)) (Î¼s pq) 

      module _ (Î´â†“â‚€ Î´â†“â‚ : (p : Pos M c) â†’ Cnsâ†“ Plbkâ†“ (Typâ†“ Mâ†“ d p , typ-d=Î½ p) (Î´ p))
               (Î´-eq : (p : Pos M c) â†’ Î´â†“â‚€ p == Î´â†“â‚ p) where

        pb-pth : Path {A = Cnsâ†“ Plbkâ†“ (j , idp) (Î¼ M c (fst âˆ˜ Î´) , Î´Î¼)}
                    (Î¼â†“ Mâ†“ d (fst âˆ˜ Î´â†“â‚€) , Î´â†“Î¼ Î´â†“â‚€)
                    (Î¼â†“ Mâ†“ d (fst âˆ˜ Î´â†“â‚) , Î´â†“Î¼ Î´â†“â‚)
        pb-pth = ap (Î» x â†’ Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x) (Î»= Î´-eq)

        module _ (Îµâ†“â‚€ : (p : Pos M c) â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , Î´â†“â‚€ p) (Îµ p))
                 (Îµâ†“â‚ : (p : Pos M c) â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , Î´â†“â‚ p) (Îµ p))
                 (Îµ-eq : (p : Pos M c) â†’ Îµâ†“â‚€ p == Îµâ†“â‚ p [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , x) (Îµ p)) â†“ Î´-eq p ]) where

          Dom : Set 
          Dom = Î£ ((p : Pos M c) â†’ Cnsâ†“ Plbkâ†“ (Typâ†“ Mâ†“ d p , typ-d=Î½ p) (Î´ p))
                (Î» Î´â†“ â†’ (p : Pos M c) â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , Î´â†“ p) (Îµ p))

          Map : (dm : Dom) â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ fst dm) , Î´â†“Î¼ (fst dm))) (nd (c , Î½) Î´ Îµ)
          Map (Î´â‡£ , Îµâ‡£) =  ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â‡£ Îµâ‡£



          something : Îµâ†“â‚€ == Îµâ†“â‚ [ (Î» x â†’ (p : Pos M c) â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , x p) (Îµ p)) â†“ Î»= Î´-eq ]
          something = â†“-Î -cst-app-in (Î» p â†’ â†“-ap-out
                                              {A = (r : Pos M c) â†’ Cnsâ†“ Plbkâ†“ (Typâ†“ Mâ†“ d r , typ-d=Î½ r) (Î´ r)}
                                              (Î» x â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , x) (Îµ p)) (Î» x â†’ x p)
                                              (Î»= Î´-eq) (transport (Î» z â†’ Îµâ†“â‚€ p == Îµâ†“â‚ p [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((Typâ†“ Mâ†“ d p , typ-d=Î½ p) , x) (Îµ p)) â†“ z ])
                                              (! (app=-Î² Î´-eq p)) (Îµ-eq p)))

          pth : Path {A = Dom} (Î´â†“â‚€ , Îµâ†“â‚€) (Î´â†“â‚ , Îµâ†“â‚)
          pth = pair= (Î»= Î´-eq) something

          can-get : ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                    == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                      [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ (fst x)) , Î´â†“Î¼ (fst x))) (nd (c , Î½) Î´ Îµ)) â†“ pth ]
          can-get = apd Map pth 

          hence : ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                    == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                      [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x)) (nd (c , Î½) Î´ Îµ)) â†“ ap fst pth ]
          hence = â†“-ap-in (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x)) (nd (c , Î½) Î´ Îµ)) fst can-get 

          need : ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                  [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x)) (nd (c , Î½) Î´ Îµ)) â†“ Î»= Î´-eq ]
          need = transport (Î» z â†’ ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                    == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                      [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , (Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x)) (nd (c , Î½) Î´ Îµ)) â†“ z ]) (fst=-Î² (Î»= Î´-eq) something) hence 

          first :  ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                     [ (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , x) (nd (c , Î½) Î´ Îµ)) â†“ pb-pth ]
          first = â†“-ap-in (Î» x â†’ Cnsâ†“ Slcâ†“ ((j , idp) , x) (nd (c , Î½) Î´ Îµ)) (Î» x â†’ Î¼â†“ Mâ†“ d (fst âˆ˜ x) , Î´â†“Î¼ x)
                  need

          and-ive-got : ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                     [ (Î» x â†’ Cnsâ†“ Slcâ†“ x (nd (c , Î½) Î´ Îµ)) â†“ ap (Î» x â†’ (j , idp) , x) pb-pth ]
          and-ive-got = â†“-ap-in (Î» x â†’ Cnsâ†“ Slcâ†“ x (nd (c , Î½) Î´ Îµ)) (Î» x â†’ (j , idp) , x)
                          first 

          -- Okay, now we'd like to get this last lemma
          claim :  ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                     [ (Î» x â†’ Cnsâ†“ Slcâ†“ x (nd (c , Î½) Î´ Îµ)) â†“ pair= idp pb-pth ]
          claim = transport (Î» z â†’ ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚€ Îµâ†“â‚€
                == ndâ†“ {fâ†“ = j , idp} (d , typ-d=Î½) Î´â†“â‚ Îµâ†“â‚
                     [ (Î» x â†’ Cnsâ†“ Slcâ†“ x (nd (c , Î½) Î´ Îµ)) â†“ z ]) idp and-ive-got


-- apâ†“ : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : A â†’ Type k}
--   (g : {a : A} â†’ B a â†’ C a) {x y : A} {p : x == y}
--   {u : B x} {v : B y}
--   â†’ (u == v [ B â†“ p ] â†’ g u == g v [ C â†“ p ])
-- apâ†“ g {p = idp} p = ap g p

-- apdâ†“ : âˆ€ {i j k} {A : Type i} {B : A â†’ Type j} {C : (a : A) â†’ B a â†’ Type k}
--   (f : {a : A} (b : B a) â†’ C a b) {x y : A} {p : x == y}
--   {u : B x} {v : B y} (q : u == v [ B â†“ p ])
--   â†’ f u == f v [ (Î» xy â†’ C (fst xy) (snd xy)) â†“ pair= p q ]
-- apdâ†“ f {p = idp} idp = idp

  -- â†“-Î -cst-app-in : {x x' : A} {p : x == x'}
  --   {u : (b : B) â†’ C x b} {u' : (b : B) â†’ C x' b}
  --   â†’ ((b : B) â†’ u b == u' b [ (Î» x â†’ C x b) â†“ p ])
  --   â†’ (u == u' [ (Î» x â†’ (b : B) â†’ C x b) â†“ p ])
  -- â†“-Î -cst-app-in {p = idp} f = Î»= f

  -- â†“-Î -in : {x x' : A} {p : x == x'} {u : Î  (B x) (C x)} {u' : Î  (B x') (C x')}
  --   â†’ ({t : B x} {t' : B x'} (q : t == t' [ B â†“ p ])
  --       â†’ u t == u' t' [ uncurry C â†“ pair= p q ])
  --   â†’ (u == u' [ (Î» x â†’ Î  (B x) (C x)) â†“ p ])
  -- â†“-Î -in {p = idp} f = Î»= (Î» x â†’ f (idp {a = x}))
